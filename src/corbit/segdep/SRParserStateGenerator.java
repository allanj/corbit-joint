/*
 * Corbit, a text analyzer
 * 
 * Copyright (c) 2010-2012, Jun Hatori
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the names of the authors nor the names of its contributors
 *       may be used to endorse or promote products derived from this
 *       software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package corbit.segdep;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Map.Entry;

import corbit.commons.ml.IntFeatVector;
import corbit.commons.transition.SDAction;
import corbit.commons.util.Pair;
import corbit.commons.word.DepChunkTree;
import corbit.commons.word.UnsegmentedSentence;
import corbit.segdep.handler.DelayedFeature;
import corbit.segdep.handler.SRParserHandler;
import corbit.segdep.transition.SRParserTransition;

public class SRParserStateGenerator
{
	private static final int m_szStack = 3;

	private final SRParserHandler m_fhandler;

	private final boolean m_bDP;
	private final boolean m_bEvalDelay;

	public SRParserStateGenerator(SRParserHandler fhandler, boolean bDP, boolean bEvalDelay)
	{
		m_fhandler = fhandler;
		m_bDP = bDP;
		m_bEvalDelay = bEvalDelay;
	}

	public SRParserState create(UnsegmentedSentence sent, SRParserTransition.Decision[] decision)
	{
		SRParserState s = m_bDP ?
				new SRParserDPState(
						sent,
						new DepChunkTree[m_szStack],
						0, 0, -1, -1, 0.0d, 0.0d,
						new LinkedList<IntFeatVector>(),
						m_bEvalDelay ? new LinkedList<DelayedFeature>() : null, new TreeSet<SRParserState>(),
						null,
						new LinkedHashMap<SRParserState,Pair<List<IntFeatVector>,Double>>(),
						decision,
						new LinkedList<SDAction>(),
						true,
						1) :
				new SRParserState(
						sent,
						new DepChunkTree[m_szStack],
						0, 0, -1, -1, 0.0d, 0.0d,
						new LinkedList<IntFeatVector>(),
						m_bEvalDelay ? new LinkedList<DelayedFeature>() : null, new TreeSet<SRParserState>(),
						null,
						new LinkedHashMap<SRParserState,Pair<List<IntFeatVector>,Double>>(),
						decision,
						new LinkedList<SDAction>(),
						true, 1);

		s.pstck[0] = new DepChunkTree(s.sent, -1, -1, DepChunkTree.rootTag, -2, -2, null);
//		for (int i = 0; i < sent.numChunks(); ++i)
//		{
//			// s.pos[i] = sent.get(i).pos;
//			s.heads[i] = sent.getChunk(i).head;
//		}
		s.calcAtomicFeatures(m_fhandler);
		return s;
	}

	SRParserState copy(SRParserState s)
	{
		SRParserState sNew = m_bDP ?
				new SRParserDPState(
						s.sent,
						s.cloneStack(),
						s.curidx, s.curstep, s.idbgn, s.idend, s.scprf, s.scins,
						s.fvins != null ? new LinkedList<IntFeatVector>(s.fvins) : null,
						m_bEvalDelay ? new LinkedList<DelayedFeature>(s.fvdelay) : null, new TreeSet<SRParserState>(s.preds),
						s.pred0,
						new LinkedHashMap<SRParserState,Pair<List<IntFeatVector>,Double>>(s.trans),
						s.decision,
						new LinkedList<SDAction>(s.lstact), s.gold,
						s.nstates) :
				new SRParserState(
						s.sent,
						s.cloneStack(),
						s.curidx, s.curstep, s.idbgn, s.idend, s.scprf, s.scins,
						s.fvins != null ? new LinkedList<IntFeatVector>(s.fvins) : null,
						m_bEvalDelay ? new LinkedList<DelayedFeature>(s.fvdelay) : null, new TreeSet<SRParserState>(s.preds),
						s.pred0,
						new LinkedHashMap<SRParserState,Pair<List<IntFeatVector>,Double>>(s.trans),
						s.decision,
						new LinkedList<SDAction>(s.lstact),
						s.gold,
						s.nstates);

		sNew.atoms = s.atoms;
		return sNew;
	}

	public SRParserState generate(
			UnsegmentedSentence sent,
			DepChunkTree[] stack,
			int curidx,
			int curstep,
			int idbgn,
			int idend,
			double scprf,
			double scins,
			List<IntFeatVector> fvins,
			List<DelayedFeature> fvdelay,
			Set<SRParserState> preds,
			SRParserState pred0,
			Map<SRParserState,Pair<List<IntFeatVector>,Double>> trans,
			SRParserTransition.Decision[] decision,
			List<SDAction> lstact,
			boolean gold,
			long states)
	{
		SRParserState s = m_bDP ?
				new SRParserDPState(
						sent, stack,
						curidx, curstep, idbgn, idend, scprf, scins,
						fvins, fvdelay, preds, pred0, trans, decision, lstact, gold, states) :
				new SRParserState(
						sent, stack,
						curidx, curstep, idbgn, idend, scprf, scins,
						fvins, fvdelay, preds, pred0, trans, decision, lstact, gold, states);
		s.calcAtomicFeatures(m_fhandler);
		return s;
	}

	public SRParserState merge(SRParserState ps1, SRParserState ps2)
	{
		assert (ps1.atoms.equals(ps2.atoms));

		if (SRParserState.isBetter(ps2, ps1))
		{
			SRParserState _ps = ps1;
			ps1 = ps2;
			ps2 = _ps;
		}

		SRParserState ps = copy(ps1);

		for (SRParserState _ps: ps2.preds)
			if (!ps.preds.contains(_ps))
				ps.preds.add(_ps);

		for (Entry<SRParserState,Pair<List<IntFeatVector>,Double>> p: ps2.trans.entrySet())
		{
			SRParserState sk = p.getKey();
			if (!ps.trans.containsKey(sk))
				ps.trans.put(sk, p.getValue());
		}

		ps.gold = ps1.gold || ps2.gold && ps1.pstck[0].equals(ps2.pstck[0]);

		ps.nstates = ps1.nstates + ps2.nstates;

		return ps;
	}

}
